utils.getFileAsText : Text ->{IO, Exception} Text
utils.getFileAsText fileName =
  path = FilePath.FilePath fileName
  bracket
    '(openFile (path) Read)
    closeFile
    (fileHandle -> Text.fromUtf8 (getBytes fileHandle (base.io.getFileSize path)))

utils.sum : [Nat] -> Nat
utils.sum = List.foldLeft (Nat.+) 0

utils.product : [Nat] -> Nat
utils.product = List.foldLeft (Nat.*) 1

utils.dist: Nat -> Nat -> Nat
utils.dist a b =
  d = a - b
  Int.truncate0 (if (d Int.< +0) then Int.negate d else d)

utils.transpose: [[a]] -> [[a]]
utils.transpose = cases
  [] -> []
  l@(h +: _) -> List.mapIndexed (n -> _ -> somes (List.map (List.at n) l)) h

test> utils.transpose.tests.ex1 = check(transpose [[1,2,3]] === [[1],[2],[3])
test> utils.transpose.tests.ex2 = check(transpose [[1,2,3], [4,5,6], [7,8,9]] === [[1,4,7],[2,5,8],[3,6,9]])

utils.elementFrequency : [a] -> [(a, Nat)]
utils.elementFrequency list = List.reverse (List.sortBy Tuple.at2 (Map.toList (Map.map Nonempty.size (List.groupBy id list))))

test> utils.elementFrequency.tests.ex1 = check (elementFrequency [1,1,1,1,1] === [(1,5)])
test> utils.elementFrequency.tests.ex2 = check (elementFrequency [0,1,1,1,1] === [(1,4), (0, 1)])

utils.parser.sepBy1 : Parser e t b -> Parser e t a -> Parser e t (List.Nonempty b)
utils.parser.sepBy1 pa ps =
  go a =
    Parser.map (as -> Nonempty a as) (some (ps *> pa))
  Parser.flatMap go pa

utils.parser.whsp : Parser e Char ()
utils.parser.whsp = many (eq ?\s) $> '()

utils.parser.newLine : Parser e Char ()
utils.parser.newLine = (eq ?\n) $> '()

utils.parser.nat : Parser e Char Nat
utils.parser.nat =
  convert s = match Nat.fromText s with
    Some n -> Parser.const n
    None -> Parser.fail (TrivialError Location.unknown (Some (Label s)) (Set.singleton (Label "natural")))
  Parser.flatMap convert (many ascii.digit $> fromCharList)

utils.parser.int : Parser e Char Int
utils.parser.int =
  convert s = match Int.fromText s with
    Some n -> Parser.const n
    None -> Parser.fail (TrivialError Location.unknown (Some (Label s)) (Set.singleton (Label "int")))
  Parser.flatMap convert (many (or (char ?-) ascii.digit) $> fromCharList)

unique type utils.Grid a = Grid [[a]]

{{ Parse a string consisting of lines of digits into a grid of Nat}}
utils.digitGrid : Text -> Grid Nat
utils.digitGrid inputText =
  Text.split ?\n inputText
    |> List.filter (t -> Text.size t > 0)
    |> List.map ((List.map ((Optional.getOrElse 0) . Nat.fromText . Char.toText)) . toCharList)
    |> Grid

test> utils.digitGrid.test.ex1 = check (utils.digitGrid "012\n345" === Grid [[0, 1, 2], [3, 4, 5]])

utils.gridDimensions : Grid a -> (Nat, Nat)
utils.gridDimensions = cases
  Grid [] -> (0,0)
  Grid l@(h +: _) -> (List.size h, List.size l)

test> utils.gridDimensions.test.ex1 = check (gridDimensions (Grid [[0, 1, 2], [3, 4, 5]]) === (3,2))

unique type utils.Position = Pos Nat Nat

utils.maxPosition : Grid a -> Position
utils.maxPosition grid = match gridDimensions grid with (x,y) -> Pos (Nat.decrement x) (Nat.decrement y)

utils.getValue : Position -> Grid a -> Optional a
utils.getValue = cases (Pos x y) -> cases (Grid data) ->
  Optional.flatMap (l -> List.at x l) (List.at y data)

utils.zipWith3 : (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
utils.zipWith3 f a b c =
  go acc as bs cs =
    match (as, bs, cs) with
      (ah +: at, bh +: bt, ch +: ct) -> go (acc :+ f ah bh ch) at bt ct
      _                    -> acc
  go [] a b c
