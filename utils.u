utils.getFileAsText : Text ->{IO, Exception} Text
utils.getFileAsText fileName =   
  path = FilePath.FilePath fileName
  bracket
    '(openFile (path) Read)
    closeFile
    (fileHandle -> Text.fromUtf8 (getBytes fileHandle (base.io.getFileSize path)))


utils.transpose: [[a]] -> [[a]]
utils.transpose = cases
  [] -> []
  l@(h +: _) -> List.mapIndexed (n -> _ -> somes (List.map (List.at n) l)) h

test> utils.transpose.tests.ex1 = check(transpose [[1,2,3]] === [[1],[2],[3])
test> utils.transpose.tests.ex2 = check(transpose [[1,2,3], [4,5,6], [7,8,9]] === [[1,4,7],[2,5,8],[3,6,9]])

utils.elementFrequency : [a] -> [(a, Nat)]
utils.elementFrequency list = List.reverse (List.sortBy Tuple.at2 (Map.toList (Map.map Nonempty.size (List.groupBy id list))))

test> utils.elementFrequency.tests.ex1 = check (elementFrequency [1,1,1,1,1] === [(1,5)])
test> utils.elementFrequency.tests.ex2 = check (elementFrequency [0,1,1,1,1] === [(1,4), (0, 1)])

> elementFrequency [1,1,1,1,1]
> elementFrequency [0,1,1,1,1]
> List.groupBy id (Text.toCharList "abababab")

utils.parser.sepBy1 : Parser e t b -> Parser e t a -> Parser e t (List.Nonempty b)
utils.parser.sepBy1 pa ps =
  go a = 
    Parser.map (as -> Nonempty a as) (some (ps *> pa))
  Parser.flatMap go pa

utils.parser.whsp : Parser e Char ()
utils.parser.whsp = many (eq ?\s) $> '()

utils.parser.newLine : Parser e Char ()
utils.parser.newLine = (eq ?\n) $> '()

utils.parser.nat : Parser e Char Nat
utils.parser.nat = 
  convert s = match Nat.fromText s with
    Some n -> Parser.const n
    None -> Parser.fail (TrivialError Location.unknown (Some (Label s)) (Set.singleton (Label "natural")))
  Parser.flatMap convert (many ascii.digit $> fromCharList)

